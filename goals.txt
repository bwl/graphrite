Here’s an updated version of the Mermaid-AI subset goals report, now incorporating official repositories and related links, and extending it with practical starting points for cloning and customizing the mermaid-js project.

⸻

Mermaid-AI Subset Goals and Implementation Roadmap

⸻

Core Objective

Design a restricted subset of Mermaid.js syntax tailored for AI readability and deterministic parsing. This subset enforces all lint rules as part of the language grammar, ensuring diagrams cannot compile unless compliant — enabling AI systems to ingest diagrams as structured data without ambiguity.

⸻

Key Goals

1. Deterministic Parsing
	•	Enforce predictable grammar (fixed keyword positions, strict casing).
	•	Mandate direction declaration (graph TD, graph LR) on first line.
	•	Disallow optional syntaxes (no A-->B without spaces).

2. Semantic Metadata
	•	Require comment headers:

%% Diagram: User authentication flow


	•	Optional metadata tags (%% Meta: type=workflow; domain=auth) for AI indexing.

3. Node & Edge Uniformity
	•	Node IDs must use snake_case.
	•	Multi-word labels must be quoted: node_id["User Login"].
	•	Enforce consistent edge semantics (--> = flow, -.-> = conditional).

4. Single Diagram Scope
	•	One diagram per fenced code block (```mermaid).
	•	No mixed diagram types (flowchart + sequenceDiagram).

5. Structural Integrity
	•	No dangling edges or orphan nodes (unless explicitly annotated).
	•	Fail compilation if referenced nodes are undefined.

6. AI-Friendly Formatting
	•	Max line length: 80–100 characters.
	•	Consistent spacing around arrows.
	•	No inline comments mid-line.

7. Compilation as Validation
	•	Diagram compilation doubles as linting: invalid diagrams fail early.
	•	Unified compiler = source of truth for both rendering and AI ingestion.

⸻

Relevant Repositories

Core Mermaid.js
	•	GitHub: https://github.com/mermaid-js/mermaid
Contains the primary codebase for diagram rendering and syntax parsing.

Mermaid CLI
	•	GitHub: https://github.com/mermaid-js/mermaid-cli
Useful for rendering diagrams to images/PDF and for CI validation.

Mermaid Live Editor
	•	GitHub: https://github.com/mermaid-js/mermaid-live-editor
Web-based environment for editing and previewing Mermaid diagrams.

Mermaid Documentation
	•	Docs: https://mermaid.js.org
Official syntax guides and API references.

⸻

Why Fork/Clone Mermaid?

Creating an AI-focused subset requires:
	•	Restricting grammar (enforce lint rules at parser level).
	•	Embedding validation logic directly into compile step.
	•	Optionally exposing structured outputs (e.g., JSON AST for AI pipelines).

Rather than building from scratch, you can clone and fork the existing mermaid-js repository, modify the parser, and introduce AI-specific checks.

⸻

Cloning and Setup

1. Clone the Repository

git clone https://github.com/mermaid-js/mermaid.git
cd mermaid

2. Install Dependencies

npm install

3. Run Build

npm run build

4. Run Tests

npm test


⸻

Modifying for AI Subset
	1.	Parser Changes:
	•	Modify the packages/parser code (PEG.js/nearley grammar) to enforce strict rules (snake_case, mandatory quotes, etc.).
	•	Remove/disable optional syntax branches.
	2.	Validation Layer:
	•	Add custom validation before rendering to block non-compliant diagrams.
	•	Output machine-readable errors (JSON) for AI pipelines.
	3.	Extended Output:
	•	Optionally extend compile step to produce AST or JSON graphs for AI use (nodes, edges, metadata).
	4.	CLI Tooling:
	•	Fork mermaid-cli and embed the AI subset compiler.
	•	Provide commands like mermaid-ai lint diagram.mmd.

⸻

Advantages of Forking
	•	Compatibility: Retain rendering features of standard Mermaid.
	•	Control: Enforce AI-specific rules without upstream compromises.
	•	Future-proofing: Sync periodically with upstream updates.

⸻

Potential Extensions
	•	Mermaid-AI JSON schema: Formal structure for AI pipelines.
	•	Mermaid-AI Editor: Restrict UI to compliant syntax (fork mermaid-live-editor).
	•	Prebuilt Validators: Export standalone validator as NPM package for other teams.

⸻

Next Steps
	1.	Define grammar spec for “Mermaid-AI” (BNF or PEG).
	2.	Implement parser changes in a fork of mermaid-js.
	3.	Integrate lint rules into compiler (hard failures).
	4.	Publish subset docs (syntax guide + JSON mapping).
	5.	Optionally provide CLI/VSCode plugin for instant feedback.

⸻

Do you want me to draft the formal grammar (BNF/PEG) for this subset so you can embed it directly into Mermaid’s parser?
Or should I write a step-by-step fork plan (with file locations, parser entry points, test strategy) for modifying the existing repo?

Would you prefer backwards compatibility (subset compiles in normal Mermaid) or a hard fork (AI-only syntax)?
